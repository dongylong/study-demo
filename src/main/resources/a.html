<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
<body id="filepos103">
<a id="filepos2325441"></a>
<p></p>
<span>第14章 多线程</span>
<p>利用对象，可将一个程序分割成相互独立的区域。我们通常也需要将一个程序转换成多个独立运行的子任务。象这样的每个子任务都叫作一个"线程"(Thread)。编写程序时，可将每个线程都想象成独立运行，而且都有自己的专用CPU。一些基础机制实际会为我们自动分割CPU的时间。我们通常不必关心这些细节问题，所以多线程的代码编写是相当简便的。这时理解一些定义对以后的学习狠有帮助。"进程"是指一种"自包容"的运行程序，有自己的地址空间。"多任务"操作系统能同时运行多个进程(程序)——但实际是由于CPU分时机制的作用，使每个进程都能循环获得自己的CPU时间片。但由于轮换速度非常快，使得所有程序好象是在"同时"运行一样。"线程"是进程内部单一的一个顺序控制流。因此，一个进程可能容纳了多个同时执行的线程。多线程的应用范围很广。但在一般情况下，程序的一些部分同特定的事件或资源联系在一起，同时又不想为它而暂停程序其他部分的执行。这样一来，就可考虑创建一个线程，令其与那个事件或资源关联到一起，并让它独立于主程序运行。一个很好的例子便是"Quit"或"退出"按钮——我们并不希望在程序的每一部分代码中都轮询这个按钮，同时又希望该按钮能及时地作出响应(使程序看起来似乎经常都在轮询它)。事实上，多线程最主要的一个用途就是构建一个"反应灵敏"的用户界面。</p>
<span>14.1 反应灵敏的用户界面</span>
<p>作为我们的起点，请思考一个需要执行某些CPU密集型计算的程序。由于CPU"全心全意"为那些计算服务，所以对用户的输入十分迟钝，几乎没有什么反应。在这里，我们用一个合成的applet/application(程序片／应用程序)来简单显示出一个计数器的结果：</p>
<p>//: Counter1.java</p>
<p>// A non-responsive user interface package c14;</p>
<p>import java.awt.*;</p>
<p>import java.awt.event.*;</p>
<p>import java.applet.*;</p>
<p>public class Counter1 extends Applet {</p>
<p>private int count = 0;</p>
<p>private Button</p>
<p>onOff = new Button("Toggle"), start = new Button("Start");</p>
<p>private TextField t = new TextField(10);</p>
<p>private boolean runFlag = true;</p>
<p>public void init() {</p>
<p>add(t);</p>
<p>start.addActionListener(new StartL());</p>
<p>add(start);</p>
<p>onOff.addActionListener(new OnOffL());</p>
<p>add(onOff);</p>
<p>}</p>
<p>public void go() {</p>
<p>while (true) {</p>
<p>try { Thread.currentThread().sleep(100);</p>
<p>} catch (InterruptedException e){}</p>
<p>if(runFlag)</p>
<p>t.setText(Integer.toString(count++));</p>
<div id="calibre_pb_501"></div>
</body>
</html>